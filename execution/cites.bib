@inproceedings{lazyevaluator,
author = {Henderson, Peter and Morris, James H.},
title = {A Lazy Evaluator},
year = {1976},
isbn = {9781450374774},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800168.811543},
doi = {10.1145/800168.811543},
abstract = {A different way to execute pure LISP programs is presented. It delays the evaluation of parameters and list structures without ever having to perform more evaluation steps than the usual method. Although the central idea can be found in earlier work this paper is of interest since it treats a rather well-known language and works out an algorithm which avoids full substitution. A partial correctness proof using Scott-Strachey semantics is sketched in a later section.},
booktitle = {Proceedings of the 3rd ACM SIGACT-SIGPLAN Symposium on Principles on Programming Languages},
pages = {95–103},
numpages = {9},
location = {Atlanta, Georgia},
series = {POPL '76}
}

@InProceedings{futamura,
author="Futamura, Yoshihiko",
editor="Goto, Eiichi
and Furukawa, Koichi
and Nakajima, Reiji
and Nakata, Ikuo
and Yonezawa, Akinori",
title="Partial computation of programs",
booktitle="RIMS Symposia on Software Science and Engineering",
year="1983",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--35",
abstract="This paper attempts to clarify the difference between partial and ordinary computation. Partial computation of a computer program is by definition ``specializing a general program based upon its operating environment into a more efficient program''. It also shows the usefulness of partial computation. Finally, the formal theory of partial computation, technical problems in making it practical, and its future research problems are discussed.",
isbn="978-3-540-39442-6"
}

@InProceedings{10.1007/978-3-540-25937-4_24,
author="Rogaway, Phillip
and Shrimpton, Thomas",
editor="Roy, Bimal
and Meier, Willi",
title="Cryptographic Hash-Function Basics: Definitions, Implications, and Separations for Preimage Resistance, Second-Preimage Resistance, and Collision Resistance",
booktitle="Fast Software Encryption",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="371--388",
abstract="We consider basic notions of security for cryptographic hash functions: collision resistance, preimage resistance, and second-preimage resistance. We give seven different definitions that correspond to these three underlying ideas, and then we work out all of the implications and separations among these seven definitions within the concrete-security, provable-security framework. Because our results are concrete, we can show two types of implications, conventional and provisional, where the strength of the latter depends on the amount of compression achieved by the hash function. We also distinguish two types of separations, conditional and unconditional. When constructing counterexamples for our separations, we are careful to preserve specified hash-function domains and ranges; this rules out some pathological counterexamples and makes the separations more meaningful in practice. Four of our definitions are standard while three appear to be new; some of our relations and separations have appeared, others have not. Here we give a modern treatment that acts to catalog, in one place and with carefully-considered nomenclature, the most basic security notions for cryptographic hash functions.",
isbn="978-3-540-25937-4"
}

@Article{Klotz2013,
author={Klotz, Johannes Georg
and Bossert, Martin
and Schober, Steffen},
title={Computing preimages of Boolean networks},
journal={BMC Bioinformatics},
year={2013},
month={Aug},
day={12},
volume={14},
number={10},
pages={S4},
abstract={In this paper we present an algorithm based on the sum-product algorithm that finds elements in the preimage of a feed-forward Boolean networks given an output of the network. Our probabilistic method runs in linear time with respect to the number of nodes in the network. We evaluate our algorithm for randomly constructed Boolean networks and a regulatory network of Escherichia coli and found that it gives a valid solution in most cases.},
issn={1471-2105},
doi={10.1186/1471-2105-14-S10-S4},
url={https://doi.org/10.1186/1471-2105-14-S10-S4}
}

@article{akutsu2009analyses,
  title={Analyses and algorithms for predecessor and control problems for Boolean networks of bounded indegree},
  author={Akutsu, Tatsuya and Hayashida, Morihiro and Zhang, Shu-Qin and Ching, Wai-Ki and Ng, Michael K},
  journal={Information and Media Technologies},
  volume={4},
  number={2},
  pages={338--349},
  year={2009},
  publisher={Information and Media Technologies Editorial Board}
}

@ARTICLE{1353287,  author={Kwok, J.T.-Y. and Tsang, I.W.-H.},  journal={IEEE Transactions on Neural Networks},   title={The pre-image problem in kernel methods},   year={2004},  volume={15},  number={6},  pages={1517-1525},  doi={10.1109/TNN.2004.837781}}


@Article{sym13040586,
AUTHOR = {Barnett, Stephen M. and Jeffers, John and Pegg, David T.},
TITLE = {Quantum Retrodiction: Foundations and Controversies},
JOURNAL = {Symmetry},
VOLUME = {13},
YEAR = {2021},
NUMBER = {4},
ARTICLE-NUMBER = {586},
URL = {https://www.mdpi.com/2073-8994/13/4/586},
ISSN = {2073-8994},
ABSTRACT = {Prediction is the making of statements, usually probabilistic, about future events based on current information. Retrodiction is the making of statements about past events based on current information. We present the foundations of quantum retrodiction and highlight its intimate connection with the Bayesian interpretation of probability. The close link with Bayesian methods enables us to explore controversies and misunderstandings about retrodiction that have appeared in the literature. To be clear, quantum retrodiction is universally applicable and draws its validity directly from conventional predictive quantum theory coupled with Bayes’ theorem.},
DOI = {10.3390/sym13040586}
}

@article{RevModPhys.27.179,
  title = {Symmetry of Physical Laws. {Part III}. Prediction and Retrodiction},
  author = {Watanabe, Satosi},
  journal = {Rev. Mod. Phys.},
  volume = {27},
  issue = {2},
  pages = {179--186},
  numpages = {0},
  year = {1955},
  month = {Apr},
  publisher = {American Physical Society},
  doi = {10.1103/RevModPhys.27.179},
  url = {https://link.aps.org/doi/10.1103/RevModPhys.27.179}
}

@Inbook{Aharonov2008,
author="Aharonov, Yakir
and Vaidman, Lev",
editor="Muga, J.G.
and Mayato, R. Sala
and Egusquiza, {\'I}.L.",
title="The Two-State Vector Formalism: An Updated Review",
bookTitle="Time in Quantum Mechanics",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="399--447",
isbn="978-3-540-73473-4",
doi="10.1007/978-3-540-73473-4_13",
url="https://doi.org/10.1007/978-3-540-73473-4_13"
}

@article{PhysRevA.54.147,
  title = {Quantum networks for elementary arithmetic operations},
  author = {Vedral, Vlatko and Barenco, Adriano and Ekert, Artur},
  journal = {Phys. Rev. A},
  volume = {54},
  issue = {1},
  pages = {147--153},
  numpages = {0},
  year = {1996},
  month = {Jul},
  publisher = {American Physical Society},
  doi = {10.1103/PhysRevA.54.147},
  url = {https://link.aps.org/doi/10.1103/PhysRevA.54.147}
}


@article{quteprints21763,
       publisher = {The University of Queensland Press},
          author = {Linda Burnett and William Millan and Edward Dawson and Andrew Clark},
            year = {2004},
           pages = {231--247},
         journal = {Australasian Journal of Combinatorics},
           title = {Simpler Methods for Generating Better Boolean Functions with Good Cryptographic Properties},
          volume = {29},
             url = {https://eprints.qut.edu.au/21763/}
}


@incollection{TOKAREVA20151,
title = {Chapter 1 - {Boolean} Functions},
editor = {Natalia Tokareva},
booktitle = {Bent Functions},
publisher = {Academic Press},
address = {Boston},
pages = {1-15},
year = {2015},
isbn = {978-0-12-802318-1},
doi = {https://doi.org/10.1016/B978-0-12-802318-1.00001-7},
url = {https://www.sciencedirect.com/science/article/pii/B9780128023181000017},
author = {Natalia Tokareva},
keywords = {Boolean function, Vectorial function, Algebraic normal form, Boolean cube, Hamming distance, Extended affine equivalence, Walsh-Hadamard transform, Finite field, Polynomial form, Trace form, Monomial function},
abstract = {In this chapter, we start with basic definitions related to Boolean functions. We consider the algebraic normal form of a Boolean function and the representation of a Boolean function over the Boolean cube. Extended affinely equivalent Boolean functions are defined as is the Walsh-Hadamard transform of a Boolean function. The finite field over F2 and its automorphisms are considered. It is shown how to associate Boolean functions in n variables with functions over the field F2n. We discuss polynomial representations of Boolean and vectorial Boolean functions. Representations of a Boolean function in the trace form and in the reduced trace form are given. Some details on the degree of a Boolean function in the trace form and on monomial functions are presented. The notions introduced in this chapter will be useful throughout the book.}
}

@inproceedings{10.1145/800027.808445,
author = {Boyer, Robert S. and Elspas, Bernard and Levitt, Karl N.},
title = {SELECT—a Formal System for Testing and Debugging Programs by Symbolic Execution},
year = {1975},
isbn = {9781450373852},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800027.808445},
doi = {10.1145/800027.808445},
abstract = {SELECT is an experimental system for assisting in the formal systematic debugging of programs. It is intended to be a compromise between an automated program proving system and the current ad hoc debugging practice, and is similar to a system being developed by King et al. of IBM. SELECT systematically handles the paths of programs written in a LISP subset that includes arrays. For each execution path SELECT returns simplified conditions on input variables that cause the path to be executed, and simplified symbolic values for program variables at the path output. For conditions which form a system of linear equalities and inequalities SELECT will return input variable values that can serve as sample test data. The user can insert constraint conditions, at any point in the program including the output, in the form of symbolically executable assertions. These conditions can induce the system to select test data in user-specified regions. SELECT can also determine if the path is correct with respect to an output assertion. We present four examples demonstrating the various modes of system operation and their effectiveness in finding bugs. In some examples, SELECT was successful in automatically finding useful test data. In others, user interaction was required in the form of output assertions. SELECT appears to be a useful tool for rapidly revealing program errors, but for the future there is a need to expand its expressive and deductive power.},
booktitle = {Proceedings of the International Conference on Reliable Software},
pages = {234–245},
numpages = {12},
keywords = {Solution of systems of inequalities, Program debugging, Symbolic execution, Program testing, Program verification, Test data generation},
location = {Los Angeles, California}
}

@article{10.1145/390016.808445,
author = {Boyer, Robert S. and Elspas, Bernard and Levitt, Karl N.},
title = {SELECT—a Formal System for Testing and Debugging Programs by Symbolic Execution},
year = {1975},
issue_date = {June 1975},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {10},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/390016.808445},
doi = {10.1145/390016.808445},
abstract = {SELECT is an experimental system for assisting in the formal systematic debugging of programs. It is intended to be a compromise between an automated program proving system and the current ad hoc debugging practice, and is similar to a system being developed by King et al. of IBM. SELECT systematically handles the paths of programs written in a LISP subset that includes arrays. For each execution path SELECT returns simplified conditions on input variables that cause the path to be executed, and simplified symbolic values for program variables at the path output. For conditions which form a system of linear equalities and inequalities SELECT will return input variable values that can serve as sample test data. The user can insert constraint conditions, at any point in the program including the output, in the form of symbolically executable assertions. These conditions can induce the system to select test data in user-specified regions. SELECT can also determine if the path is correct with respect to an output assertion. We present four examples demonstrating the various modes of system operation and their effectiveness in finding bugs. In some examples, SELECT was successful in automatically finding useful test data. In others, user interaction was required in the form of output assertions. SELECT appears to be a useful tool for rapidly revealing program errors, but for the future there is a need to expand its expressive and deductive power.},
journal = {SIGPLAN Not.},
month = {apr},
pages = {234–245},
numpages = {12},
keywords = {Program debugging, Program verification, Test data generation, Symbolic execution, Program testing, Solution of systems of inequalities}
}


@article{10.1145/360248.360252,
author = {King, James C.},
title = {Symbolic Execution and Program Testing},
year = {1976},
issue_date = {July 1976},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {19},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/360248.360252},
doi = {10.1145/360248.360252},
abstract = {This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may be symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and debugging is also described. It interpretively executes programs written in a simple PL/I style programming language. It includes many standard debugging features, the ability to manage and to prove things about symbolic expressions, a simple program testing manager, and a program verifier. A brief discussion of the relationship between symbolic execution and program proving is also included.},
journal = {Commun. ACM},
month = {jul},
pages = {385–394},
numpages = {10},
keywords = {symbolic execution, program proving, symbolic interpretation, program verification, program testing, program debugging}
}

@InProceedings{howden,
  author = 	 {William E. Howden},
  title = 	 {Experiments with a symbolic evaluation system},
  booktitle = {Proceedings of the National Computer Conference},
  year = 	 1976}

@inproceedings{10.1145/800191.805647,
author = {Clarke, Lori A.},
title = {A Program Testing System},
year = {1976},
isbn = {9781450374897},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800191.805647},
doi = {10.1145/800191.805647},
abstract = {A system that aids in testing programs is described. This system symbolically executes program paths and creates symbolic representations of the output variables that aid in verifying a path's computations. The conditional statements that affect the flow of control are also symbolically represented by a set of inequalities. The inequalities are then evaluated to determine input data that would cause execution of the path. The system also does extensive error checking by simulating possible data dependent errors and then attempting to detect data sets that would cause execution errors.},
booktitle = {Proceedings of the 1976 Annual Conference},
pages = {488–491},
numpages = {4},
location = {Houston, Texas, USA},
series = {ACM '76}
}

@article{10.1145/3182657,
author = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
title = {A Survey of Symbolic Execution Techniques},
year = {2018},
issue_date = {May 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/3182657},
doi = {10.1145/3182657},
abstract = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
journal = {ACM Comput. Surv.},
month = {may},
articleno = {50},
numpages = {39},
keywords = {static analysis, software testing, Symbolic execution, concolic execution}
}

@Article{djdeq,
  author = 	 {Alastair A. Abbott},
  title = 	 {The {Deutsch-Jozsa} problem: de-quantization and entanglement},
  journal = 	 {Natural Computing},
  year = 	 2012,
  volume = 	 11}


@article{10.2307/3560059,
 ISSN = {13645021},
 URL = {http://www.jstor.org/stable/3560059},
 abstract = {For any quantum algorithm operating on pure states, we prove that the presence of multi-partite entanglement, with a number of parties that increases unboundedly with input size, is necessary if the quantum algorithm is to offer an exponential speed-up over classical computation. Furthermore, we prove that the algorithm can be efficiently simulated classically to within a prescribed tolerance η even if a suitably small amount of global entanglement is present. We explicitly identify the occurrence of increasing multi-partite entanglement in Shor's algorithm. Our results do not apply to quantum algorithms operating on mixed states in general and we discuss the suggestion that an exponential computational speed-up might be possible with mixed states in the total absence of entanglement. Finally, despite the essential role of entanglement for pure-state algorithms, we argue that it is nevertheless misleading to view entanglement as a key resource for quantum-computational power.},
 author = {Richarda Jozsa and Noah Linden},
 journal = {Proceedings: Mathematical, Physical and Engineering Sciences},
 number = {2036},
 pages = {2011--2032},
 publisher = {The Royal Society},
 title = {On the Role of Entanglement in Quantum-Computational Speed-Up},
 volume = {459},
 year = {2003}
}

